<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NativeCal Interactive Prototype</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Date FNS -->
    <script src="https://cdn.jsdelivr.net/npm/date-fns@3.6.0/cdn.min.js"></script>
    
    <style>
        /* Basic grid for month view */
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            border-top: 1px solid #e5e7eb;
            border-left: 1px solid #e5e7eb;
        }
        .calendar-cell {
            min-height: 100px;
            border-right: 1px solid #e5e7eb;
            border-bottom: 1px solid #e5e7eb;
            padding: 0.25rem;
        }
        /* Time grid (Week/Day) */
        .time-grid {
            display: grid;
            /* First col is labels (60px), rest are dates */
            /* Template columns set dynamically via inline style */
        }
        .time-col {
            border-right: 1px solid #e5e7eb;
            min-width: 0; 
            position: relative;
        }
        .hour-row {
            height: 50px; /* 50px per hour */
            border-bottom: 1px solid #f3f4f6;
            box-sizing: border-box;
        }
        
        /* Year View */
        .year-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            padding: 1.5rem;
        }
        .mini-month-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
        }
        
        .event-card {
            transition: box-shadow 0.1s, transform 0.1s, width 0.2s ease-out, left 0.2s ease-out;
            z-index: 10;
            /* width and left are now set dynamically via style */
        }
        
        .event-card:hover {
            z-index: 50 !important;
        }
        
        .event-card.is-dragging {
            opacity: 0.5;
            z-index: 60 !important;
        }
        
        /* Active Drag State (Cute) */
        .event-card.dragging-active {
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            z-index: 100 !important;
            opacity: 0.9;
        }
        
        .event-card.dragging-move-active {
            transform: rotate(3deg) scale(1.02);
        }

        .resize-handle {
            cursor: ns-resize;
        }
        .resize-handle:hover {
            background-color: rgba(0,0,0,0.1);
        }

        /* Drag Ghost */
        .drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.9;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            transform: translate(-50%, -50%) rotate(3deg) scale(1.05);
        }

        /* Utilities */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        
        /* Prevent text selection during drag */
        .select-none { user-select: none; }
    </style>
</head>
<body class="bg-gray-50 p-4 text-gray-800 h-screen flex flex-col">
    <div id="app" class="flex flex-col h-full max-w-6xl mx-auto bg-white shadow rounded-lg overflow-hidden select-none">
        
        <!-- Header / Toolbar -->
        <div class="p-4 border-b border-gray-200 flex justify-between items-center flex-shrink-0">
            <div class="flex items-center gap-4">
                <h1 class="text-xl font-bold tracking-tight text-blue-600">NativeCal</h1>
                
                <!-- Navigation -->
                <div class="flex items-center bg-gray-100 rounded p-0.5">
                    <button @click="prev" class="px-2 hover:bg-white rounded h-8 flex items-center">&lt;</button>
                    <button @click="today" class="px-3 text-sm font-medium hover:bg-white rounded h-8">Today</button>
                    <button @click="next" class="px-2 hover:bg-white rounded h-8 flex items-center">&gt;</button>
                </div>
                
                <span class="text-lg font-medium w-48">{{ currentTitle }}</span>
            </div>
            
            <div class="flex gap-2">
                <button v-for="view in views" 
                    :key="view"
                    @click="changeView(view)"
                    :class="['px-3 py-1 rounded text-sm transition-colors', currentView === view ? 'bg-blue-600 text-white' : 'bg-gray-100 hover:bg-gray-200']">
                    {{ view }}
                </button>
            </div>
        </div>

        <!-- View Container -->
        <div class="flex-1 overflow-hidden relative">
            
            <!-- Month View -->
            <div v-if="currentView === 'Month'" class="h-full flex flex-col overflow-y-auto">
                <!-- Headers -->
                <div class="grid grid-cols-7 border-b border-gray-200 bg-gray-50">
                    <div v-for="day in weekDays" :key="day" class="py-2 text-center text-sm font-semibold text-gray-500 uppercase tracking-wide">
                        {{ day }}
                    </div>
                </div>
                <!-- Grid -->
                <div class="calendar-grid flex-1">
                    <div v-for="(cell, idx) in monthCells" :key="idx" 
                         class="calendar-cell relative group hover:bg-gray-50 flex flex-col gap-1 cursor-pointer"
                         :class="{'bg-gray-50/50': !cell.isCurrentMonth, 'bg-blue-50': isToday(cell.date)}"
                         :data-date="cell.date.toISOString()"
                         @click.self="createMonthEvent(cell.date)">
                        
                        <span class="text-xs font-medium p-1 ml-auto rounded-full w-7 h-7 flex items-center justify-center"
                              :class="isToday(cell.date) ? 'bg-blue-600 text-white' : 'text-gray-700'">
                            {{ cell.dayNumber }}
                        </span>

                        <!-- Month Events -->
                        <div v-for="event in getEventsForDate(cell.date)" :key="event.id"
                             class="px-1.5 py-0.5 text-xs rounded truncate cursor-pointer shadow-sm border-l-2 hover:brightness-95 transition-all select-none"
                             :class="{'is-dragging': dragState.eventId === event.id}"
                             :style="getEventStyle(event)"
                             @mousedown.stop="startDrag(event, $event, 'month-move')"
                             @click.stop="selectEvent(event, $event)">
                            {{ event.title }}
                        </div>
                    </div>
                </div>
            </div>

            <!-- Time Grid View (Week/Day) -->
            <div v-if="currentView === 'Week' || currentView === 'Day'" class="h-full flex flex-col">
                <!-- Header Row -->
                <div class="border-b border-gray-200 bg-white flex-shrink-0 grid"
                     :style="`grid-template-columns: 60px repeat(${visibleDates.length}, 1fr)`">
                    <div class="border-r border-gray-200 p-2"></div> <!-- Gutter -->
                    <div v-for="(date, idx) in visibleDates" :key="idx" 
                         class="p-2 text-center border-r border-gray-100">
                        <div class="text-xs font-semibold text-gray-500 uppercase">{{ weekDays[date.getDay()] }}</div>
                        <div class="text-xl font-light w-8 h-8 mx-auto rounded-full flex items-center justify-center" 
                             :class="{'bg-blue-600 text-white font-bold': isToday(date)}">
                            {{ date.getDate() }}
                        </div>
                    </div>
                </div>

                <!-- Scrollable Area -->
                <div class="flex-1 overflow-y-auto relative" ref="timeScroll">
                    <div class="time-grid relative min-h-[1200px]"
                         :style="`grid-template-columns: 60px repeat(${visibleDates.length}, 1fr)`">
                        
                        <!-- Time Labels (Left Gutter) -->
                        <div class="flex flex-col text-xs text-gray-400 text-right pr-2 pt-[-0.5rem] bg-white sticky left-0 z-10 border-r border-gray-200">
                            <div v-for="h in 24" :key="h" class="h-[50px] -mt-2.5 bg-white select-none">{{ h-1 }}:00</div>
                        </div>
                        
                        <!-- Day Columns -->
                        <div v-for="(date, idx) in visibleDates" :key="idx" 
                             class="time-col relative"
                             :data-date="date.toISOString()"
                             @click="createTimeEvent(date, $event)">
                            
                            <!-- Grid lines -->
                            <div v-for="h in 24" :key="h" class="hour-row pointer-events-none"></div>
                            
                            <!-- Current Time Indicator -->
                            <div v-if="isToday(date)" class="absolute w-full h-0.5 bg-red-500 z-30 pointer-events-none flex items-center"
                                 :style="{ top: currentTimeTop + 'px' }">
                                 <div class="w-2 h-2 bg-red-500 rounded-full -ml-1"></div>
                            </div>

                            <!-- Original Position Ghost (When Dragging) -->
                            <div v-if="dragState.isDragging && isSameDay(date, new Date(dragState.originalStart)) && dragState.action === 'time-move'"
                                 class="absolute inset-x-1 rounded border-2 border-gray-400 border-dashed bg-gray-100 opacity-60 pointer-events-none z-0"
                                 :style="getGhostStyle()">
                            </div>

                            <!-- Absolute Events -->
                            <div v-for="event in getEventsWithLayout(date)" :key="event.id" 
                                 class="event-card absolute p-1 text-xs inset-x-1 rounded overflow-hidden border-l-4"
                                 :class="{
                                     'dragging-active': dragState.eventId === event.id && dragState.isDragging, 
                                     'dragging-move-active': dragState.eventId === event.id && dragState.isDragging && dragState.action === 'time-move',
                                     'ring-2 ring-offset-1 ring-black': selectedEventId === event.id
                                 }"
                                 :style="[getEventStyle(event, true), getWeekEventPosition(event), { cursor: eventCursor }]"
                                 @mousedown.stop="startDrag(event, $event, 'time-move')"
                                 @click.stop="selectEvent(event, $event)">
                                <div class="event-text-content">
                                    <div class="font-bold leading-tight pointer-events-none">{{ event.title }}</div>
                                    <div class="opacity-75 text-[10px] pointer-events-none">{{ formatTime(event.start) }} - {{ formatTime(event.end) }}</div>
                                </div>
                                <!-- Resize Handle -->
                                <div class="resize-handle absolute bottom-0 inset-x-0 h-2 z-20"
                                     @mousedown.stop="startDrag(event, $event, 'resize')"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Year View -->
            <div v-if="currentView === 'Year'" class="h-full overflow-y-auto p-4">
                <div class="year-grid">
                    <div v-for="(month, idx) in yearMonths" :key="idx" class="border rounded p-2 hover:shadow-md transition-shadow cursor-pointer"
                         @click="goToMonth(month.date)">
                        <h3 class="text-center font-bold text-gray-700 mb-2">{{ month.name }}</h3>
                        <div class="mini-month-grid">
                            <div v-for="day in ['S','M','T','W','T','F','S']" :key="day" class="text-[10px] text-center text-gray-400">{{ day }}</div>
                            
                            <!-- Empty start cells -->
                            <div v-for="n in month.startPad" :key="'pad-'+n"></div>
                            
                            <!-- Days -->
                            <div v-for="day in month.days" :key="day.date" 
                                 class="text-center text-xs p-1 rounded-full"
                                 :class="{'bg-blue-600 text-white': isToday(day.date), 'bg-blue-100': day.hasEvents && !isToday(day.date)}">
                                {{ day.dayNumber }}
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Agenda View -->
            <div v-if="currentView === 'Agenda'" class="h-full overflow-y-auto p-4">
                <div class="max-w-3xl mx-auto space-y-6">
                    <div v-if="agendaEvents.length === 0" class="text-center text-gray-500 py-10">No events found.</div>
                    
                    <div v-for="(group, dateStr) in agendaEvents" :key="dateStr">
                        <div class="sticky top-0 bg-gray-50/95 backdrop-blur py-2 border-b border-gray-200 mb-2 z-10">
                            <span class="font-bold text-lg">{{ group.formattedDate }}</span>
                            <span v-if="group.isToday" class="ml-2 text-xs bg-blue-600 text-white px-2 py-0.5 rounded-full">Today</span>
                        </div>
                        <div class="space-y-2">
                            <div v-for="event in group.events" :key="event.id" 
                                 class="flex gap-4 p-3 bg-white rounded border-l-4 shadow-sm hover:shadow cursor-pointer"
                                 :style="{ borderLeftColor: getEventColor(event) }"
                                 @click.stop="selectEvent(event, $event)">
                                <div class="w-24 text-right text-sm text-gray-500 flex-shrink-0">
                                    <div>{{ formatTime(event.start) }}</div>
                                    <div class="text-xs opacity-75">{{ formatDuration(event) }}</div>
                                </div>
                                <div>
                                    <div class="font-bold text-gray-800">{{ event.title }}</div>
                                    <div class="text-xs text-gray-500">Type {{ event.type }}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <!-- Quick Info Popup -->
        <div v-if="selectedEventId" 
             class="fixed z-50 bg-white rounded-lg shadow-xl border border-gray-200 p-4 w-72"
             :style="popupStyle">
             <div class="flex justify-between items-start mb-2">
                <h3 class="font-bold text-lg truncate">{{ getEventById(selectedEventId)?.title }}</h3>
                <button @click="closePreview" class="text-gray-400 hover:text-gray-600">âœ•</button>
             </div>
             <div class="text-sm text-gray-600 mb-4" v-if="getEventById(selectedEventId)">
                {{ formatTime(getEventById(selectedEventId).start) }} - {{ formatTime(getEventById(selectedEventId).end) }}
             </div>
             <div class="flex justify-end gap-2">
                <button @click="deleteEvent(selectedEventId)" class="text-red-500 hover:bg-red-50 px-3 py-1 rounded text-sm font-medium">Delete</button>
                <button @click="openEditor(selectedEventId)" class="bg-blue-600 text-white px-3 py-1 rounded hover:bg-blue-700 text-sm font-medium">Edit</button>
             </div>
        </div>

        <!-- Edit Modal -->
        <div v-if="isEditorOpen" class="fixed inset-0 z-[100] flex items-center justify-center bg-black/50" @click.self="closeEditor">
            <div class="bg-white rounded-lg shadow-xl w-full max-w-md p-6 m-4">
                <h2 class="text-xl font-bold mb-4">Edit Event</h2>
                
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Title</label>
                        <input v-model="editorForm.title" type="text" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm border p-2 focus:border-blue-500 focus:ring-blue-500">
                    </div>
                    
                    <!-- Simple time inputs for prototype -->
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700">Start</label>
                            <div class="text-gray-900 mt-1">{{ formatTime(editorForm.start) }}</div>
                        </div>
                         <div>
                            <label class="block text-sm font-medium text-gray-700">End</label>
                            <div class="text-gray-900 mt-1">{{ formatTime(editorForm.end) }}</div>
                        </div>
                    </div>

                    <div>
                        <label class="block text-sm font-medium text-gray-700">Color</label>
                        <div class="flex gap-2 mt-1">
                            <div v-for="(c, i) in colors" :key="i" 
                                 class="w-6 h-6 rounded-full cursor-pointer ring-offset-2"
                                 :class="{'ring-2 ring-blue-500': editorForm.type === i + 1}"
                                 :style="{backgroundColor: c}"
                                 @click="editorForm.type = i + 1"></div>
                        </div>
                    </div>
                </div>

                <div class="mt-6 flex justify-end gap-3">
                    <button @click="closeEditor" class="px-4 py-2 text-gray-700 hover:bg-gray-100 rounded-md">Cancel</button>
                    <button @click="saveEvent" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Save</button>
                </div>
            </div>
        </div>

        <!-- Drag Ghost (Month View) -->
        <div v-if="dragState.isDragging && dragState.action === 'month-move' && dragState.ghostEvent" 
             class="drag-ghost px-2 py-1 text-xs rounded text-white font-bold truncate w-32 pointer-events-none"
             :style="[getEventStyle(dragState.ghostEvent), { left: dragState.mouseX + 'px', top: dragState.mouseY + 'px' }]">
            {{ dragState.ghostEvent.title }}
        </div>

        <!-- Simple Toast/Hint -->
        <div v-if="notification" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white px-4 py-2 rounded-full text-sm shadow-lg z-50 transition-opacity">
            {{ notification }}
        </div>
    </div>

    <script>
        const { createApp, ref, computed, onMounted, onUnmounted } = Vue;
        const df = window.dateFns;

        createApp({
            setup() {
                const currentView = ref('Month'); // Default view
                const views = ['Day', 'Week', 'Month', 'Year', 'Agenda'];
                const currentDate = ref(new Date());
                const weekDays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                const notification = ref('');
                const selectedEventId = ref(null);
                const popupPosition = ref({ top: 0, left: 0 });
                const isEditorOpen = ref(false);
                const editorForm = ref({ id: null, title: '', start: 0, end: 0, type: 1 });
                
                // ----------------------------------------------------------------
                // Data
                // ----------------------------------------------------------------
                const events = ref([
                    { id: 1, title: 'Morning Standup', start: new Date().setHours(9, 0, 0, 0), end: new Date().setHours(9, 30, 0, 0), type: 1 },
                    { id: 2, title: 'Deep Work', start: new Date().setHours(10, 0, 0, 0), end: new Date().setHours(12, 0, 0, 0), type: 2 },
                    { id: 3, title: 'Lunch', start: new Date().setHours(12, 30, 0, 0), end: new Date().setHours(13, 30, 0, 0), type: 3 },
                    { id: 4, title: 'Client Meeting', start: new Date().setHours(14, 0, 0, 0), end: new Date().setHours(15, 0, 0, 0), type: 4 },
                ]);

                const colors = ["#3f51b5", "#e3165b", "#ff6652", "#4caf50", "#ff9800", "#03a9f4", "#9e9e9e", "#27282f"];

                // ----------------------------------------------------------------
                // Computed Props
                // ----------------------------------------------------------------
                const eventCursor = computed(() => {
                    if (dragState.value.isDragging && dragState.value.eventId) {
                        return dragState.value.action === 'resize' ? 'ns-resize' : 'grabbing';
                    }
                    return 'pointer';
                });

                const currentTitle = computed(() => {
                    if (currentView.value === 'Year') return df.format(currentDate.value, 'yyyy');
                    if (currentView.value === 'Day') return df.format(currentDate.value, 'MMMM d, yyyy');
                    return df.format(currentDate.value, 'MMMM yyyy');
                });

                const popupStyle = computed(() => {
                    // Keep popup within bounds roughly
                    let left = popupPosition.value.left;
                    let top = popupPosition.value.top;
                    
                    // Adjust if too close to right edge (simplistic)
                    if (window.innerWidth - left < 300) left -= 300;
                    // Adjust if too close to bottom
                    if (window.innerHeight - top < 200) top -= 200;
                    
                    return {
                        top: `${top}px`,
                        left: `${left}px`
                    };
                });

                const getEventById = (id) => events.value.find(e => e.id === id);

                // Month View Logic
                const monthCells = computed(() => {
                    const start = df.startOfMonth(currentDate.value);
                    const end = df.endOfMonth(currentDate.value);
                    const days = df.eachDayOfInterval({ start, end });
                    const startDay = df.getDay(start);
                    const prevMonthDays = [];
                    for(let i = 0; i < startDay; i++) {
                        prevMonthDays.unshift({
                            date: df.subDays(start, i + 1),
                            dayNumber: df.getDate(df.subDays(start, i + 1)),
                            isCurrentMonth: false
                        });
                    }
                    const currentMonthDays = days.map(d => ({ date: d, dayNumber: df.getDate(d), isCurrentMonth: true }));
                    // Pad end
                    const totalCells = 42; // 6 rows
                    const remaining = totalCells - (prevMonthDays.length + currentMonthDays.length);
                    const nextMonthDays = [];
                    for(let i = 1; i <= remaining; i++) {
                        nextMonthDays.push({
                            date: df.addDays(end, i),
                            dayNumber: df.getDate(df.addDays(end, i)),
                            isCurrentMonth: false
                        });
                    }
                    
                    return [...prevMonthDays, ...currentMonthDays, ...nextMonthDays];
                });

                // Week/Day View Logic
                const visibleDates = computed(() => {
                    if (currentView.value === 'Day') {
                        return [currentDate.value];
                    }
                    // Week view
                    const start = df.startOfWeek(currentDate.value);
                    return Array.from({ length: 7 }, (_, i) => df.addDays(start, i));
                });

                // Year View Logic
                const yearMonths = computed(() => {
                    const yearStart = df.startOfYear(currentDate.value);
                    const months = df.eachMonthOfInterval({
                        start: yearStart,
                        end: df.endOfYear(currentDate.value)
                    });

                    return months.map(m => {
                        const start = df.startOfMonth(m);
                        const end = df.endOfMonth(m);
                        const days = df.eachDayOfInterval({ start, end });
                        return {
                            name: df.format(m, 'MMMM'),
                            date: m,
                            startPad: df.getDay(start),
                            days: days.map(d => ({
                                date: d,
                                dayNumber: df.getDate(d),
                                hasEvents: events.value.some(e => df.isSameDay(new Date(e.start), d))
                            }))
                        };
                    });
                });

                // Agenda View Logic
                const agendaEvents = computed(() => {
                    // Sort all events by start date
                    const sorted = [...events.value].sort((a, b) => a.start - b.start);
                    
                    // Group by date
                    const groups = {};
                    sorted.forEach(event => {
                        const dateKey = df.format(new Date(event.start), 'yyyy-MM-dd');
                        if (!groups[dateKey]) {
                            groups[dateKey] = {
                                date: new Date(event.start),
                                formattedDate: df.format(new Date(event.start), 'EEEE, MMMM d'),
                                isToday: df.isSameDay(new Date(event.start), new Date()),
                                events: []
                            };
                        }
                        groups[dateKey].events.push(event);
                    });
                    return groups; // Object (not ordered), usually okay for v-for but better as array
                });

                // ----------------------------------------------------------------
                // Methods: Navigation
                // ----------------------------------------------------------------
                const changeView = (view) => {
                    currentView.value = view;
                    selectedEventId.value = null; // Close preview
                };

                const prev = () => {
                    if (currentView.value === 'Year') currentDate.value = df.subYears(currentDate.value, 1);
                    else if (currentView.value === 'Month') currentDate.value = df.subMonths(currentDate.value, 1);
                    else if (currentView.value === 'Week') currentDate.value = df.subWeeks(currentDate.value, 1);
                    else currentDate.value = df.subDays(currentDate.value, 1);
                    selectedEventId.value = null; // Close preview
                };
                const next = () => {
                    if (currentView.value === 'Year') currentDate.value = df.addYears(currentDate.value, 1);
                    else if (currentView.value === 'Month') currentDate.value = df.addMonths(currentDate.value, 1);
                    else if (currentView.value === 'Week') currentDate.value = df.addWeeks(currentDate.value, 1);
                    else currentDate.value = df.addDays(currentDate.value, 1);
                    selectedEventId.value = null; // Close preview
                };
                const today = () => {
                    currentDate.value = new Date();
                    selectedEventId.value = null; // Close preview
                };
                const isToday = (date) => df.isSameDay(date, new Date());
                const goToMonth = (date) => {
                    currentDate.value = date;
                    currentView.value = 'Month';
                    selectedEventId.value = null; // Close preview
                };

                // ----------------------------------------------------------------
                // Methods: Event Logic
                // ----------------------------------------------------------------
                const getEventsForDate = (date) => {
                    return events.value.filter(e => df.isSameDay(new Date(e.start), date));
                };

                // Layout Algorithm for Week/Day View
                const getEventsWithLayout = (date) => {
                    const dayEvents = getEventsForDate(date).map(e => ({...e})); // Shallow copy to attach layout props
                    if (dayEvents.length === 0) return [];

                    // Sort by start time, then end time (descending duration)
                    dayEvents.sort((a, b) => a.start - b.start || b.end - a.end);

                    const columns = [];
                    dayEvents.forEach(ev => {
                        let placed = false;
                        for (let i = 0; i < columns.length; i++) {
                            const col = columns[i];
                            // Check if this event overlaps with the LAST event in this column
                            // (Simple packing) - actually need to check all in column to be safe,
                            // but usually just checking the last one is enough if sorted? 
                            // No, if we have A(9-11), B(9-10), C(10-11). A is col 0. B is col 1. C? 
                            // C starts at 10. A ends at 11. C cannot be col 0.
                            // C starts at 10. B ends at 10. C DOES NOT overlap B. C can be col 1.
                            
                            const hasOverlap = col.some(existing => {
                                return Math.max(existing.start, ev.start) < Math.min(existing.end, ev.end);
                            });
                            
                            if (!hasOverlap) {
                                col.push(ev);
                                ev.colIndex = i;
                                placed = true;
                                break;
                            }
                        }
                        if (!placed) {
                            columns.push([ev]);
                            ev.colIndex = columns.length - 1;
                        }
                    });

                    // Now calculate Width and Left
                    // Simple Approach: Width = 100% / total columns in the "cluster"
                    // For this prototype, we will use global columns for the day for simplicity,
                    // or we can try to find max_col_index for the specific event's cluster.
                    
                    // Let's do a simplified "shared width" approach:
                    // If I am in col 0, and there is a col 1 that overlaps me, we share space.
                    
                    // We will use a generic "Max Columns" for the day to avoid complex cluster logic for now.
                    // This means if there is a 4-event overlap at 9am, ALL events in the day might be 1/4 width.
                    // This is suboptimal but robust for a first pass. 
                    // IMPROVEMENT: Calculate max overlap for each event's connected component.
                    
                    // Better: Calculate overlaps per event.
                    dayEvents.forEach(ev => {
                        // Find all overlapping events
                        const overlapping = dayEvents.filter(other => 
                            Math.max(ev.start, other.start) < Math.min(ev.end, other.end)
                        );
                        // The "width" is 1 / (max concurrent events in this group).
                        // The "left" depends on the colIndex.
                        
                        // Actually, simpler visual:
                        // width = 100 / columns.length (global max columns)
                        // This ensures alignment.
                        
                        const widthPercent = 100 / columns.length;
                        ev.style = {
                            left: (ev.colIndex * widthPercent) + '%',
                            width: (widthPercent * 0.8) + '%' // Events take 80% of their column space
                        };
                    });
                    
                    return dayEvents;
                };

                const formatTime = (timestamp) => df.format(new Date(timestamp), 'h:mm a');
                const formatDuration = (event) => {
                    const diff = df.differenceInMinutes(event.end, event.start);
                    const h = Math.floor(diff / 60);
                    const m = diff % 60;
                    return (h > 0 ? `${h}h ` : '') + (m > 0 ? `${m}m` : ''); 
                };

                const getEventStyle = (event, isWeekView = false) => {
                    const color = colors[(event.type - 1) % colors.length];
                    if (isWeekView) {
                        return { 
                            borderLeftColor: color, 
                            backgroundColor: color + '20', 
                            color: color,
                            ...event.style // Apply layout styles (left, width)
                        };
                    }
                    return { backgroundColor: color, color: 'white' };
                };
                const getEventColor = (event) => colors[(event.type - 1) % colors.length];

                const getWeekEventPosition = (event) => {
                    const start = new Date(event.start);
                    const end = new Date(event.end);
                    const startMinutes = start.getHours() * 60 + start.getMinutes();
                    const endMinutes = end.getHours() * 60 + end.getMinutes();
                    const top = (startMinutes / 60) * 50;
                    const height = Math.max(((endMinutes - startMinutes) / 60) * 50, 20);
                    return { top: `${top}px`, height: `${height}px` }; // Width/Left handled by layout style
                };
                
                const getGhostStyle = () => {
                    const start = new Date(dragState.value.originalStart);
                    const end = new Date(dragState.value.originalEnd);
                    const startMinutes = start.getHours() * 60 + start.getMinutes();
                    const endMinutes = end.getHours() * 60 + end.getMinutes();
                    const top = (startMinutes / 60) * 50;
                    const height = Math.max(((endMinutes - startMinutes) / 60) * 50, 20);
                    return { top: `${top}px`, height: `${height}px`, width: '80%', left: '0%' }; // Ghost is left aligned 80% width
                };

                // ----------------------------------------------------------------
                // Hover Guide Logic (Removed - no longer needed)
                // ----------------------------------------------------------------

                // ----------------------------------------------------------------
                // Interactions
                // ----------------------------------------------------------------
                const showToast = (msg) => {
                    notification.value = msg;
                    setTimeout(() => notification.value = '', 2000);
                }

                const createMonthEvent = (date) => {
                    console.log('[createMonthEvent] triggered for', date);
                    const start = df.setHours(date, 9);
                    const end = df.setHours(date, 10);
                    events.value.push({ id: Date.now(), title: 'New Event', start: start.getTime(), end: end.getTime(), type: Math.floor(Math.random() * 8) + 1 });
                    showToast(`Created event on ${df.format(date, 'MMM d')}`);
                };

                const createTimeEvent = (date, event) => {
                    console.log('[createTimeEvent] triggered. Dragging:', dragState.value.isDragging);
                    if (dragState.value.isDragging) {
                        console.log('[createTimeEvent] Blocked because dragging is active');
                        return;
                    }
                    
                    // Check if we just finished a drag (click often fires after drag release)
                    if (dragState.value.wasDragging) {
                         console.log('[createTimeEvent] Blocked because we just finished dragging');
                         dragState.value.wasDragging = false;
                         return;
                    }

                    // Ensure click wasn't on an event (extra safety)
                    // Note: @click.stop on event-card should prevent this, but this is a fallback
                    if (event.target.closest('.event-card')) {
                        console.log('[createTimeEvent] Blocked because target is event-card');
                        return;
                    }
                    
                    // Clear previous selection
                    selectedEventId.value = null;

                    const rect = event.currentTarget.getBoundingClientRect();
                    const y = event.clientY - rect.top;
                    const hoursFloat = y / 50;
                    const hours = Math.floor(hoursFloat);
                    const roundedMinutes = 0; // Snap to the hour start
                    const start = df.set(date, { hours: hours, minutes: roundedMinutes });
                    const end = df.addMinutes(start, 60);
                    const newEvent = { id: Date.now(), title: '(No Title)', start: start.getTime(), end: end.getTime(), type: Math.floor(Math.random() * 8) + 1 };
                    events.value.push(newEvent);
                    selectedEventId.value = newEvent.id; // Select newly created
                    showToast(`Created at ${df.format(start, 'h:mm a')}`);
                };

                const editEvent = (event) => {
                    // Legacy double click handler if needed, now redirected to openEditor
                    openEditor(event.id);
                };

                const selectEvent = (event, e) => {
                    console.log('[selectEvent] triggered for', event.id);
                    if (dragState.value.isDragging || dragState.value.wasDragging) return;
                    selectedEventId.value = event.id;
                    
                    // Calculate popup position
                    if (e) {
                        // Position relative to viewport
                        const rect = e.currentTarget.getBoundingClientRect();
                        // Place to the right or bottom of the element
                        popupPosition.value = {
                            top: rect.bottom + 10,
                            left: rect.left + (rect.width / 2)
                        };
                    }
                };

                const closePreview = () => {
                    selectedEventId.value = null;
                };

                const deleteEvent = (id) => {
                    if(confirm("Delete this event?")) {
                        events.value = events.value.filter(e => e.id !== id);
                        selectedEventId.value = null;
                    }
                };

                const openEditor = (id) => {
                    const event = getEventById(id);
                    if (event) {
                        editorForm.value = { ...event };
                        isEditorOpen.value = true;
                        selectedEventId.value = null; // Close preview
                    }
                };

                const closeEditor = () => {
                    isEditorOpen.value = false;
                };

                const saveEvent = () => {
                    const index = events.value.findIndex(e => e.id === editorForm.value.id);
                    if (index !== -1) {
                        events.value[index] = { ...editorForm.value };
                        showToast('Event saved');
                    }
                    closeEditor();
                };

                // ----------------------------------------------------------------
                // Drag & Drop (Unified)
                // ----------------------------------------------------------------
                const dragState = ref({
                    eventId: null,
                    isDragging: false,
                    wasDragging: false, // New flag to prevent click-after-drag
                    startY: 0, // For Time Grid
                    originalStart: 0,
                    originalEnd: 0,
                    action: 'move', // 'time-move', 'month-move', 'resize'
                    ghostEvent: null, // For Month Move
                    mouseX: 0,
                    mouseY: 0
                });

                const startDrag = (event, e, action) => {
                    console.log('[startDrag] action:', action, 'id:', event.id);
                    if (e.button !== 0) return;
                    dragState.value = {
                        eventId: event.id,
                        isDragging: false,
                        wasDragging: false,
                        startY: e.clientY,
                        originalStart: event.start,
                        originalEnd: event.end,
                        action: action,
                        ghostEvent: event,
                        mouseX: e.clientX,
                        mouseY: e.clientY
                    };
                };

                const onDrag = (e) => {
                    if (!dragState.value.eventId) return;
                    
                    if (!dragState.value.isDragging) {
                        const deltaY = Math.abs(e.clientY - dragState.value.startY);
                        const deltaX = Math.abs(e.clientX - dragState.value.mouseX);
                        console.log(`[onDrag] Check threshold: dx=${deltaX}, dy=${deltaY}`);
                        
                        // Threshold check to prevent accidental micro-drags on click
                        if (deltaY > 5 || deltaX > 5) {
                            console.log('[onDrag] Drag started (threshold passed)');
                            dragState.value.isDragging = true;
                        } else {
                            return;
                        }
                    }

                    // Update Mouse Position for Month Ghost
                    dragState.value.mouseX = e.clientX;
                    dragState.value.mouseY = e.clientY;

                    const event = events.value.find(ev => ev.id === dragState.value.eventId);
                    if (!event) return;

                    // Time Grid Logic (Move/Resize)
                    if (dragState.value.action === 'time-move' || dragState.value.action === 'resize') {
                        const deltaPixels = e.clientY - dragState.value.startY;
                        const deltaMinutes = Math.round((deltaPixels / 50) * 60 / 30) * 30;

                        if (dragState.value.action === 'time-move') {
                            const duration = dragState.value.originalEnd - dragState.value.originalStart;
                            
                            // Calculate time based on original + delta (vertical move)
                            const newStartTime = df.addMinutes(dragState.value.originalStart, deltaMinutes);
                            const newHours = newStartTime.getHours();
                            const newMinutes = newStartTime.getMinutes();
                            
                            // Find target column (horizontal move)
                            const target = document.elementFromPoint(e.clientX, e.clientY);
                            let targetDate = null;
                            if (target) {
                                const col = target.closest('.time-col');
                                if (col && col.dataset.date) {
                                    targetDate = new Date(col.dataset.date);
                                }
                            }
                            
                            // Use target date if found, else keep current event date
                            const baseDate = targetDate ? targetDate : new Date(event.start);
                            
                            const newStart = df.set(baseDate, {
                                hours: newHours,
                                minutes: newMinutes
                            });
                            
                            event.start = newStart.getTime();
                            event.end = new Date(newStart.getTime() + duration).getTime();

                        } else if (dragState.value.action === 'resize') {
                            let newEnd = df.addMinutes(dragState.value.originalEnd, deltaMinutes);
                            const start = new Date(dragState.value.originalStart);
                            if (df.differenceInMinutes(newEnd, start) < 15) newEnd = df.addMinutes(start, 15);
                            event.end = newEnd.getTime();
                        }
                    }
                    // Month Move Logic handled in stopDrag (Drop)
                };

                const stopDrag = (e) => {
                    console.log('[stopDrag] isDragging:', dragState.value.isDragging);
                    if (!dragState.value.eventId) {
                        return;
                    }
                    
                    const wasDragging = dragState.value.isDragging;

                    if (wasDragging) {
                        // Handle Drop logic
                        if (dragState.value.action === 'month-move') {
                            // ... (Month drop logic) ...
                            const target = document.elementFromPoint(e.clientX, e.clientY);
                            const cell = target.closest('.calendar-cell');
                            if (cell && cell.dataset.date) {
                                const targetDate = new Date(cell.dataset.date);
                                const event = events.value.find(ev => ev.id === dragState.value.eventId);
                                if (event) {
                                    const duration = event.end - event.start;
                                    const newStart = df.set(targetDate, {
                                        hours: new Date(event.start).getHours(),
                                        minutes: new Date(event.start).getMinutes()
                                    });
                                    event.start = newStart.getTime();
                                    event.end = newStart.getTime() + duration;
                                    showToast(`Moved to ${df.format(targetDate, 'MMM d')}`);
                                }
                            }
                        } else {
                            const action = dragState.value.action === 'resize' ? 'resized' : 'moved';
                            showToast(`Event ${action}`);
                        }
                    }

                    // Reset state, but keep wasDragging true momentarily for click handlers
                    dragState.value = { 
                        eventId: null, 
                        isDragging: false, 
                        wasDragging: wasDragging, // Preserve this!
                        action: 'move' 
                    };
                    
                    // Clear wasDragging after a microtask to let click events fire and see the flag
                    setTimeout(() => {
                        dragState.value.wasDragging = false;
                    }, 50);
                };

                // ----------------------------------------------------------------
                // Time Indicator & Init
                // ----------------------------------------------------------------
                const currentTimeTop = ref(0);
                const updateTimeIndicator = () => {
                    const now = new Date();
                    currentTimeTop.value = ((now.getHours() * 60 + now.getMinutes()) / 60) * 50;
                };

                let timer;
                onMounted(() => {
                    updateTimeIndicator();
                    timer = setInterval(updateTimeIndicator, 60000);
                    setTimeout(() => {
                        const scroll = document.querySelector('.overflow-y-auto.relative');
                        if(scroll) scroll.scrollTop = 350; 
                    }, 100);
                    
                    // Global event listeners for drag
                    window.addEventListener('mousemove', onDrag);
                    window.addEventListener('mouseup', stopDrag);
                });
                onUnmounted(() => {
                    clearInterval(timer);
                    window.removeEventListener('mousemove', onDrag);
                    window.removeEventListener('mouseup', stopDrag);
                });

                return {
                    currentView, views, currentTitle, weekDays, monthCells, visibleDates, yearMonths, agendaEvents,
                    prev, next, today, isToday, changeView, goToMonth,
                    events, getEventsForDate, getEventsWithLayout, getEventStyle, getWeekEventPosition, getGhostStyle, formatTime, formatDuration, getEventColor,
                    createMonthEvent, createTimeEvent, editEvent, selectEvent, selectedEventId,
                    closePreview, openEditor, closeEditor, saveEvent, deleteEvent, isEditorOpen, editorForm, popupStyle, getEventById,
                    startDrag, onDrag, stopDrag, dragState,
                    currentTimeTop, notification, eventCursor,
                    isSameDay: (d1, d2) => df.isSameDay(d1, d2)
                }
            }
        }).mount('#app');
    </script>
</body>
</html>